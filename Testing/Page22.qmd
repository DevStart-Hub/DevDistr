---
title: "DevDist page2"
format:
   dashboard:
    theme: sandstone
    highlight-style: github
server: shiny
---

```{r}
#| label: Libraries
#| context: setup
library(shiny)
library(bslib)
library(fitdistrplus)
library(tinyplot)
```

# Distributions

## Row

### {.sidebar width="20%"}

```{r}
#| label: Distribution Selection
selectizeInput("dist_selection", "Select Distribution:",
              choices = list(
                "Continuous" = c("Normal", "Lognormal", "Student's t", "Beta"),
                "Categorical" = c("Bernoulli", "Categorical")
              ),
              selected = "Normal")
```

```{r}
#| label: Normal
# Normal
conditionalPanel(
  condition = "input.dist_selection == 'Normal'",
  sliderInput("n_mu", "Mean (μ)", value = 0, min = -5, max = 5, step = 0.1),
  helpText(HTML("Moves the center left/right.<br>"),style = "font-size: 0.6rem;"),
  sliderInput("n_sigma", "SD (σ)", value = 1, min = 0.1, max = 3, step = 0.1),
  helpText(HTML("Controls width of the distribution.<br>"),style = "font-size: 0.6rem;")
)
```

```{r}
#| label: Lognormal
# Lognormal
conditionalPanel(
  condition = "input.dist_selection == 'Lognormal'",
  sliderInput("ln_meanlog", "Log Mean (μ)", value = 0, min = -3, max = 3, step = 0.1),
  helpText(HTML("Mean of the underlying normal distribution.<br>"),style = "font-size: 0.6rem;"),
  sliderInput("ln_sdlog", "Log SD (σ)", value = 0.6, min = 0.1, max = 2, step = 0.1),
  helpText(HTML("SD of the underlying normal distribution.<br>"),style = "font-size: 0.6rem;")
)
```

```{r}
#| label: Student's t
# Student's t
conditionalPanel(
  condition = "input.dist_selection == 'Student\\'s t'",
  sliderInput("t_df", "Degrees of Freedom (ν)", value = 4, min = 1, max = 20, step = 1),
  helpText(HTML("Higher values approximate Normal (lighter tails).<br>"),style = "font-size: 0.6rem;"),
  sliderInput("t_mu", "Location (μ)", value = 0, min = -5, max = 5, step = 0.1),
  helpText(HTML("Shifts the distribution left/right.<br>"),style = "font-size: 0.6rem;"),
  sliderInput("t_sigma", "Scale (σ)", value = 1, min = 0.1, max = 3, step = 0.1),
  helpText(HTML("Controls spread (larger = wider).<br>"),style = "font-size: 0.6rem;")
)
```

```{r}
#| label: Beta
# Beta
conditionalPanel(
  condition = "input.dist_selection == 'Beta'",
  radioButtons("beta_mode", "Parameterization:",
               c("Mean μ & Precision φ" = "muphi",
                 "Alpha & Beta" = "ab"),
               inline = TRUE),

  conditionalPanel(
    condition = "input.beta_mode == 'muphi'",
    sliderInput("b_mu", "Mean (μ in (0,1))", value = 0.3, min = 0.01, max = 0.99, step = 0.01),
    helpText(HTML("Shifts the peak between 0 and 1.<br>"),style = "font-size: 0.6rem;"),
    sliderInput("b_phi", "Precision (φ > 0)", value = 20, min = 1, max = 100, step = 1),
    helpText(HTML("Higher φ = more concentrated around μ.<br>"),style = "font-size: 0.6rem;")
  ),

  conditionalPanel(
    condition = "input.beta_mode == 'ab'",
    sliderInput("b_alpha", "Alpha (α > 0)", value = 3, min = 0.1, max = 20, step = 0.1),
    helpText(HTML("Higher α shifts toward 1.<br>"),style = "font-size: 0.6rem;"),
    sliderInput("b_beta", "Beta (β > 0)", value = 7, min = 0.1, max = 20, step = 0.1),
    helpText(HTML("Higher β shifts toward 0.<br>"),style = "font-size: 0.6rem;")
  )
)
```

```{r}
#| label: Bernoulli
# Bernoulli
conditionalPanel(
  condition = "input.dist_selection == 'Bernoulli'",
  sliderInput("bern_p", "Probability of Success (p)", value = 0.5, min = 0.01, max = 0.99, step = 0.01),
  helpText(HTML("Probability of getting 'Success' (or 'True').<br>"), style = "font-size: 0.6rem;"),
  radioButtons("bern_labels", "Outcome Labels:",
               c("Success/Failure" = "success",
                 "True/False" = "logical",
                 "Yes/No" = "yesno",
                 "1/0" = "binary"),
               selected = "success",
               inline = TRUE)
)
```

```{r}
#| label: Categorical
# Categorical with constrained probabilities
conditionalPanel(
  condition = "input.dist_selection == 'Categorical'",
  sliderInput("cat_k", "Number of categories (k)", value = 4, min = 2, max = 10, step = 1),
  helpText(HTML("Number of possible outcomes.<br>"), style = "font-size: 0.6rem;"),
  
  # Display remaining probability
  uiOutput("remaining_prob_display"),
  
  conditionalPanel(
    condition = "input.cat_k >= 2",
    uiOutput("cat_p1_slider")
  ),
  conditionalPanel(
    condition = "input.cat_k >= 3",
    uiOutput("cat_p2_slider")
  ),
  conditionalPanel(
    condition = "input.cat_k >= 4",
    uiOutput("cat_p3_slider")
  ),
  conditionalPanel(
    condition = "input.cat_k >= 5",
    uiOutput("cat_p4_slider")
  ),
  conditionalPanel(
    condition = "input.cat_k >= 6",
    uiOutput("cat_p5_slider")
  ),
  conditionalPanel(
    condition = "input.cat_k >= 7",
    uiOutput("cat_p6_slider")
  ),
  conditionalPanel(
    condition = "input.cat_k >= 8",
    uiOutput("cat_p7_slider")
  ),
  conditionalPanel(
    condition = "input.cat_k >= 9",
    uiOutput("cat_p8_slider")
  ),
  conditionalPanel(
    condition = "input.cat_k >= 10",
    uiOutput("cat_p9_slider")
  ),
  
  helpText(HTML("Remaining probability is automatically assigned to the last category.<br>"), style = "font-size: 0.6rem;")
)
```

### Column {width="60%"}


#### {.tabset}

##### Plot

```{r}
#| label: Distribution Plot
plotOutput("dist_plot", height = 360)
```

##### Distribution Info

```{r}
#| label: Model Info
uiOutput("distribution_info")
```

##### How to model 
```{r}
#| label: How to model conditional panels
# Normal Distribution
# Using just code() without pre
conditionalPanel(
  condition = "input.dist_selection == 'Normal'",
  h3("Frequentist (lme4)"),
  p("To model data with a normal distribution in a frequentist framework, you can use the ", 
    code("lmer()"), " function for linear mixed-effects models. Since the normal distribution is the default assumption, you don't need to specify any family. Here's a basic example:"),
  p(code("model <- lmer(reaction_time ~ condition + (1|participant), data = your_data)")),
  p("This assumes your response variable (", code("reaction_time"), 
    ") follows a normal distribution with random intercepts for participants."),
  h3("Bayesian (brms)"),
  p("To model data with a normal distribution in a Bayesian framework, you can use the ", 
    code("brm()"), " function from the ", code("brms"), " package:"),
  p(code("model <- brm(reaction_time ~ condition + (1|participant), data = your_data)"))
),

conditionalPanel(
  condition = "input.dist_selection == 'Lognormal'",
  h3("Frequentist (lme4)"),
  p("The lme4 package does not directly support lognormal distributions. However, you can log-transform your data and use ", code("lmer()"), " with the normal distribution:"),
  p(code("model <- lmer(log(reaction_time) ~ condition + (1|participant), data = your_data)")),
  p("Remember that your coefficients will be on the log scale and need back-transformation for interpretation."),
  h3("Bayesian (brms)"),
  p("brms supports lognormal distributions directly using the ", code("lognormal()"), " family:"),
  p(code("model <- brm(reaction_time ~ condition + (1|participant), family = lognormal(), data = your_data)")),
  p("This is often preferable to log-transformation as it maintains the original scale for interpretation.")
),

conditionalPanel(
  condition = "input.dist_selection == 'Student\\'s t'",
  h3("Frequentist (lme4)"),
  p("The lme4 package does not support Student's t distributions for the response variable. lme4 assumes normally distributed residuals and uses t-distributions only for inference (confidence intervals and p-values)."),
  h3("Bayesian (brms)"),
  p("brms supports Student's t distributions using the ", code("student()"), " family, which is useful for robust modeling when you expect outliers:"),
  p(code("model <- brm(iq_score ~ group + (1|school), family = student(), data = your_data)")),
  p("The t-distribution provides more robust estimates when your data contains extreme values that might unduly influence a normal model.")
),

conditionalPanel(
  condition = "input.dist_selection == 'Beta'",
  h3("Frequentist (lme4)"),
  p("The lme4 package does not support beta distributions. For proportion data, you might consider using ", code("glmer()"), " with a binomial family if you have count data, or transform your proportions using logit transformation."),
  h3("Bayesian (brms)"),
  p("brms supports beta distributions using the ", code("Beta()"), " family, perfect for modeling proportions and percentages:"),
  p(code("model <- brm(accuracy_rate ~ condition + (1|participant), family = Beta(), data = your_data)")),
  p("Your response variable should be bounded between 0 and 1. If you have percentages (0-100), divide by 100 first.")
),

conditionalPanel(
  condition = "input.dist_selection == 'Bernoulli'",
  h3("Frequentist (lme4)"),
  p("For Bernoulli (binary) data, use ", code("glmer()"), " with the binomial family:"),
  p(code("model <- glmer(correct ~ condition + (1|participant), family = binomial(), data = your_data)")),
  p("Your response variable should be coded as 0/1 or FALSE/TRUE. The model will use logistic regression."),
  h3("Bayesian (brms)"),
  p("For Bernoulli data in brms, use the ", code("bernoulli()"), " family:"),
  p(code("model <- brm(correct ~ condition + (1|participant), family = bernoulli(), data = your_data)")),
  p("Like with lme4, your response should be binary (0/1). The ", code("bernoulli()"), " family is equivalent to ", code("binomial()"), " for single trials.")
),

conditionalPanel(
  condition = "input.dist_selection == 'Categorical'",
  h3("Frequentist (lme4)"),
  p("The lme4 package does not directly support categorical (multinomial) distributions for mixed-effects models. You would need to use packages like ", code("MCMCglmm"), " or convert to binary comparisons."),
  h3("Bayesian (brms)"),
  p("brms supports categorical data using the ", code("categorical()"), " family for multinomial responses:"),
  p(code("model <- brm(choice ~ condition + (1|participant), family = categorical(), data = your_data)")),
  p("Your response variable should be a factor with multiple levels (e.g., 'Option A', 'Option B', 'Option C'). brms will model the probability of each category.")
)

# OPTION 2: Mix of HTML functions and helpText (good for explanatory content)
conditionalPanel(
  condition = "input.dist_selection == 'Lognormal'",
  h3("Frequentist (lme4)"),
  helpText("The lme4 package does not directly support lognormal distributions. However, you can log-transform your data and use lmer() with the normal distribution:"),
  pre(code("model <- lmer(log(reaction_time) ~ condition + (1|participant), data = your_data)", 
           class = "language-r")),
  helpText(HTML("<strong>Note:</strong> Your coefficients will be on the log scale and need back-transformation for interpretation.")),
  h3("Bayesian (brms)"),
  helpText("brms supports lognormal distributions directly using the lognormal() family:"),
  pre(code("model <- brm(reaction_time ~ condition + (1|participant), family = lognormal(), data = your_data)", 
           class = "language-r")),
  helpText("This is often preferable to log-transformation as it maintains the original scale for interpretation.")
)

# OPTION 3: Bootstrap-styled with div containers (best visual hierarchy)
conditionalPanel(
  condition = "input.dist_selection == 'Beta'",
  div(class = "card mb-3",
    div(class = "card-header",
      h4("Frequentist (lme4)", class = "mb-0")
    ),
    div(class = "card-body",
      p("The lme4 package does not support beta distributions. For proportion data, you might consider using ", 
        code("glmer()"), " with a binomial family if you have count data, or transform your proportions using logit transformation.")
    )
  ),
  div(class = "card mb-3",
    div(class = "card-header",
      h4("Bayesian (brms)", class = "mb-0")
    ),
    div(class = "card-body",
      p("brms supports beta distributions using the ", code("Beta()"), " family, perfect for modeling proportions and percentages:"),
      pre(code("model <- brm(accuracy_rate ~ condition + (1|participant), family = Beta(), data = your_data)", 
               class = "language-r")),
      div(class = "alert alert-info",
        strong("Important: "), "Your response variable should be bounded between 0 and 1. If you have percentages (0-100), divide by 100 first."
      )
    )
  )
)

# OPTION 4: Using HTML() for inline formatting (when you need specific HTML)
conditionalPanel(
  condition = "input.dist_selection == 'Bernoulli'",
  h3("Frequentist (lme4)"),
  p(HTML("For <strong>Bernoulli</strong> (binary) data, use <code>glmer()</code> with the binomial family:")),
  pre(code("model <- glmer(correct ~ condition + (1|participant), family = binomial(), data = your_data)", 
           class = "language-r")),
  p(HTML("Your response variable should be coded as <code>0/1</code> or <code>FALSE/TRUE</code>. The model will use logistic regression.")),
  h3("Bayesian (brms)"),
  p(HTML("For Bernoulli data in <strong>brms</strong>, use the <code>bernoulli()</code> family:")),
  pre(code("model <- brm(correct ~ condition + (1|participant), family = bernoulli(), data = your_data)", 
           class = "language-r")),
  p(HTML("Like with lme4, your response should be binary (0/1). The <code>bernoulli()</code> family is equivalent to <code>binomial()</code> for single trials."))
)
```

### Column {width="20%"}
```{r}
#| label: Summary Stats2
uiOutput("vb_moments")
```


```{r}
#| label: Server logic
#| context: server

# Custom function to replace brms::rstudent_t
rstudent_t_custom <- function(n, df, mu = 0, sigma = 1) {
  mu + sigma * rt(n, df)
}

# Function to generate categorical samples
rcategorical <- function(n, probs) {
  sample(1:length(probs), n, replace = TRUE, prob = probs)
}

# Helper function to determine category from distribution name
get_dist_category <- function(dist_name) {
  continuous_dists <- c("Normal", "Lognormal", "Student's t", "Beta")
  if (dist_name %in% continuous_dists) {
    "Continuous"
  } else {
    "Categorical"
  }
}

# ---- Reactive sampler ----
samples <- reactive({
  n_req <- 3000L
  selected_dist <- input$dist_selection
  
  if (get_dist_category(selected_dist) == "Continuous") {
    if (selected_dist == "Normal") {
      rnorm(n_req, mean = input$n_mu, sd = input$n_sigma)
    } else if (selected_dist == "Lognormal") {
      rlnorm(n_req, meanlog = input$ln_meanlog, sdlog = input$ln_sdlog)
    } else if (selected_dist == "Student's t") {
      rstudent_t_custom(n_req, df = input$t_df, mu = input$t_mu, sigma = input$t_sigma)
    } else if (selected_dist == "Beta") {
      if (input$beta_mode == "ab") {
        alpha <- input$b_alpha
        beta  <- input$b_beta
      } else {
        mu  <- input$b_mu
        phi <- input$b_phi
        alpha <- mu * phi
        beta  <- (1 - mu) * phi
      }
      rbeta(n_req, shape1 = alpha, shape2 = beta)
    } else {
      validate(need(FALSE, "Unknown continuous distribution."))
    }
  } else if (get_dist_category(selected_dist) == "Categorical") {
    if (selected_dist == "Bernoulli") {
      # Generate Bernoulli samples (0s and 1s)
      rbinom(n_req, size = 1, prob = input$bern_p)
    } else if (selected_dist == "Categorical") {
      # Get probabilities for categorical distribution
      k <- input$cat_k
      probs <- numeric(k)
      
      if (k >= 2) probs[1] <- input$cat_p1
      if (k >= 3) probs[2] <- input$cat_p2
      if (k >= 4) probs[3] <- input$cat_p3
      if (k >= 5) probs[4] <- input$cat_p4
      if (k >= 6) probs[5] <- input$cat_p5
      if (k >= 7) probs[6] <- input$cat_p6
      if (k >= 8) probs[7] <- input$cat_p7
      if (k >= 9) probs[8] <- input$cat_p8
      if (k >= 10) probs[9] <- input$cat_p9
      
      # Assign remaining probability to last category
      probs[k] <- 1 - sum(probs[1:(k-1)])
      
      # Ensure all probabilities are positive
      if (any(probs <= 0)) {
        probs <- rep(1/k, k)  # Equal probabilities if invalid
      }
      
      rcategorical(n_req, probs)
    } else {
      validate(need(FALSE, "Unknown categorical distribution."))
    }
  } else {
    validate(need(FALSE, "Unknown distribution."))
  }
})

output$dist_plot <- renderPlot({
  s <- samples()
  selected_dist <- input$dist_selection
 
  if (get_dist_category(selected_dist) == "Continuous") {
    # Use tinyplot for continuous distributions
    tinyplot(s, type = "density", lwd = 3,
            bw='SJ',
            adjust=.5,
            kernel = "gaussian",
            n = 512,
            main = paste("Sampled", selected_dist, "Distribution"),
            xlab = "Value",
            ylab = "Density",
            col = "#007e7e",
            fill= "#007e7e")
   
    # Add histogram overlay
    tinyplot_add(
      s,
      type = "hist",
      freq = FALSE,
      col = 'black',
      fill= 'transparent',
      lwd=1
    )
   
    # Add reference lines
    abline(v = 0, col = "black", lty = 1, lwd = 1.2)
    abline(h = 0, col = "black", lty = 1, lwd = 1.2)
   
  } else if (get_dist_category(selected_dist) == "Categorical") {
    if (selected_dist == "Bernoulli") {
      # Bernoulli: create lollipop plot
      counts <- table(s)
     
      # Create labels based on user choice
      if (input$bern_labels == "success") {
        labels <- c("Failure", "Success")
      } else if (input$bern_labels == "logical") {
        labels <- c("False", "True")
      } else if (input$bern_labels == "yesno") {
        labels <- c("No", "Yes")
      } else {
        labels <- c("0", "1")
      }
     
      # Get probabilities and positions
      y_vals <- as.numeric(counts) / length(s)
      x_pos <- 1:length(y_vals)
      plot_labels <- labels[as.numeric(names(counts)) + 1]
     
      # Create empty plot
      plot(x_pos, y_vals,
           type = "n",
           main = paste("Bernoulli Distribution (p =", input$bern_p, ")"),
           xlab = "Outcome",
           ylab = "Probability",
           xaxt = "n",
           ylim = c(0, 1),
           xlim = c(0.5, length(y_vals) + 0.5))
     
      # Add vertical lines (stems)
      segments(x0 = x_pos, y0 = 0, x1 = x_pos, y1 = y_vals,
               col = "#007e7e", lwd = 4)
     
      # Add dots at the top
      points(x_pos, y_vals,
             pch = 19, cex = 2.5,
             col = "#007e7e")
      abline(h = 0, col = "black", lty = 1, lwd = 2)

      # Add custom x-axis labels
      axis(1, at = x_pos, labels = plot_labels)
     
      # Add probability values as text above dots
      text(x_pos, y_vals + 0.05,
           labels = sprintf("%.3f", y_vals),
           cex = 0.9, pos = 3)
             
    } else if (selected_dist == "Categorical") {
      # Categorical: create lollipop plot
      counts <- table(s)
      x_vals <- paste("Cat", names(counts))
      y_vals <- as.numeric(counts) / length(s)
     
      # Create positions for x-axis
      x_pos <- 1:length(y_vals)
     
      # Create empty plot with appropriate limits
      plot(x_pos, y_vals,
           type = "n",
           main = paste("Sampled Categorical Distribution (k=", input$cat_k, ")"),
           xlab = "Category",
           ylab = "Probability",
           xaxt = "n",
           ylim = c(0, max(y_vals) * 1.15),
           xlim = c(0.5, length(y_vals) + 0.5))
     
      # Add vertical lines (stems)
      segments(x0 = x_pos, y0 = 0, x1 = x_pos, y1 = y_vals,
               col = rainbow(length(y_vals)), lwd = 4)
     
      # Add dots at the top
      points(x_pos, y_vals,
             pch = 19, cex = 2.5,
             col = rainbow(length(y_vals)))
      abline(h = 0, col = "black", lty = 1, lwd = 2)

      # Add custom x-axis labels
      axis(1, at = x_pos, labels = x_vals)
     
      # Add probability values as text above dots
      text(x_pos, y_vals + max(y_vals) * 0.05,
           labels = sprintf("%.3f", y_vals),
           cex = 0.8, pos = 3)
    }
  }
}, height = function() {
  session$clientData$output_dist_plot_height
}, width = function() {
  session$clientData$output_dist_plot_width
}, res = 96)


# ---- Summary stats ----
stats <- reactive({
  s <- samples()
  selected_dist <- input$dist_selection
  n <- length(s)
  
  if (get_dist_category(selected_dist) == "Continuous") {
    q <- quantile(s, c(0.25, 0.75), names = FALSE)
    list(
      mean   = mean(s),
      median = median(s),
      sd     = sd(s),
      se     = sd(s) / sqrt(n),
      min    = min(s),
      q1     = q[1],
      q3     = q[2],
      max    = max(s),
      type   = "continuous"
    )
  } else {
    # For categorical, provide different stats
    list(
      mean   = mean(s),
      median = median(s),
      mode   = as.numeric(names(sort(table(s), decreasing = TRUE))[1]),
      var    = var(s),
      min    = min(s),
      max    = max(s),
      type   = "categorical"
    )
  }
})

output$vb_moments <- renderUI({
  st <- stats()
  selected_dist <- input$dist_selection
  
  if (st$type == "continuous") {
    tagList(
      tags$div(style = "background-color: #f8f9fa; border-radius: 8px; padding: 15px; margin-bottom: 10px;",
        tags$h4("Center & Spread", style = "margin-bottom: 12px; color: #495057; font-weight: 600;"),
        tags$div(style = "font-size: 0.9rem; line-height: 1.4; margin-bottom: 8px; color: #6c757d;",
                 sprintf("Mean: %.3f | Median: %.3f", st$mean, st$median)),
        tags$div(style = "font-size: 0.9rem; line-height: 1.4; color: #6c757d;",
                 sprintf("SD: %.3f | SE: %.3f", st$sd, st$se))
      ),
      tags$div(style = "background-color: #f8f9fa; border-radius: 8px; padding: 15px;",
        tags$h4("Range & Quartiles", style = "margin-bottom: 12px; color: #495057; font-weight: 600;"),
        tags$div(style = "font-size: 0.9rem; line-height: 1.4; margin-bottom: 8px; color: #6c757d;",
                 sprintf("Min: %.3f | Max: %.3f", st$min, st$max)),
        tags$div(style = "font-size: 0.9rem; line-height: 1.4; color: #6c757d;",
                 sprintf("Q1: %.3f | Q3: %.3f", st$q1, st$q3))
      )
    )
  } else {
    tagList(
      tags$div(style = "background-color: #f8f9fa; border-radius: 8px; padding: 15px; margin-bottom: 10px;",
        tags$h4("Center & Spread", style = "margin-bottom: 12px; color: #495057; font-weight: 600;"),
        tags$div(style = "font-size: 0.9rem; line-height: 1.4; margin-bottom: 8px; color: #6c757d;",
                 sprintf("Mean: %.3f | Mode: %.0f", st$mean, st$mode)),
        tags$div(style = "font-size: 0.9rem; line-height: 1.4; color: #6c757d;",
                 sprintf("Variance: %.3f", st$var))
      ),
      tags$div(style = "background-color: #f8f9fa; border-radius: 8px; padding: 15px;",
        tags$h4("Range", style = "margin-bottom: 12px; color: #495057; font-weight: 600;"),
        tags$div(style = "font-size: 0.9rem; line-height: 1.4; color: #6c757d;",
                 sprintf("Min: %.0f | Max: %.0f", st$min, st$max))
      )
    )
  }
})

output$distribution_info <- renderUI({
  selected_dist <- input$dist_selection
 
  if (selected_dist == "Normal") {
    tagList(
      h2("Normal (Gaussian) Distribution"),
      p("The normal distribution is the classic bell-shaped curve that forms the foundation of many statistical tests, including ANOVA and t-tests. This distribution has a single peak at its center with symmetric slopes extending to both sides. When the curve is wide, it indicates greater variability in the data - meaning your subjects have more diverse values. When the curve is narrow, it shows less variability, suggesting that most subjects have similar values clustered around the average."),
      h3("Which data fits this distribution?"),
      p("The normal distribution is ideal for continuous data that is symmetrically distributed around a central value. Common examples include human height, weight, blood pressure readings, temperature measurements, test scores, and measurement errors. Many natural phenomena tend to follow this pattern.")
    )
  } else if (selected_dist == "Lognormal") {
    tagList(
      h2("Lognormal Distribution"),
      p("The lognormal distribution appears when the logarithm of your data follows a normal distribution. Unlike the normal distribution, this curve is right-skewed, meaning it has a long tail extending toward higher values. This creates a distinctive shape where most values cluster at the lower end, but a few observations stretch out to much higher values."),
      h3("Which data fits this distribution?"),
      p("Lognormal distributions commonly appear in income data, stock prices, reaction times, file sizes, and biological measurements like cell counts or concentration levels. It's particularly useful for modeling positive values that can vary over several orders of magnitude.")
    )
  } else if (selected_dist == "Student's t") {
    tagList(
      h2("Student's t Distribution"),
      p("The t-distribution looks similar to the normal distribution but with heavier tails, meaning more extreme values are possible. As your sample size increases, the t-distribution approaches the normal distribution. This distribution accounts for the additional uncertainty that comes with estimating parameters from smaller samples."),
      h3("Which data fits this distribution?"),
      p("The t-distribution is primarily used in hypothesis testing when working with small sample sizes (typically n < 30) or when the population standard deviation is unknown. It's the foundation for t-tests, confidence intervals for means, and regression analysis.")
    )
  } else if (selected_dist == "Beta") {
    tagList(
      h2("Beta Distribution"),
      p("The beta distribution is extremely flexible and is defined only between 0 and 1, making it perfect for modeling proportions, probabilities, and percentages. Depending on its parameters, it can take many different shapes - from uniform to U-shaped to bell-shaped curves."),
      h3("Which data fits this distribution?"),
      p("Beta distributions are ideal for modeling percentages, success rates, conversion rates, test scores expressed as proportions, market share data, or any measurement that represents a fraction of a whole. It's also commonly used in Bayesian statistics as a prior distribution for probabilities.")
    )
  } else if (selected_dist == "Bernoulli") {
    tagList(
      h2("Bernoulli Distribution"),
      p("The Bernoulli distribution is the simplest probability distribution, representing a single trial with only two possible outcomes: success (1) or failure (0). Think of it as a single coin flip - you either get heads or tails. The distribution is characterized by a single parameter: the probability of success."),
      h3("Which data fits this distribution?"),
      p("Bernoulli distributions model binary outcomes such as pass/fail, yes/no responses, click/no-click in web analytics, presence/absence of a disease, or any situation where you're measuring whether something happened or not in a single trial.")
    )
  } else if (selected_dist == "Categorical") {
    tagList(
      h2("Categorical Distribution"),
      p("The categorical distribution extends the concept of the Bernoulli distribution to multiple categories. Instead of just two outcomes, you can have any number of mutually exclusive categories. Each category has its own probability, and all probabilities must sum to 1. This is also known as the multinomial distribution for a single trial."),
      h3("Which data fits this distribution?"),
      p("Categorical distributions are ideal for psychological data with multiple distinct categories: personality types (introvert/ambivert/extravert), diagnostic categories, Likert scale responses (strongly disagree/disagree/neutral/agree/strongly agree), cognitive strategies used, emotional states, attachment styles, or choice behavior in decision-making tasks. They're essential for analyzing survey data and experimental choices in psychology research.")
    )
  }
})


output$how_to_model_info <- renderUI({
  selected_dist <- input$dist_selection
 
  if (selected_dist == "Normal") {
    tagList(
      h3("Frequentist (lme4)"),
      p("To model data with a normal distribution in a frequentist framework, you can use the `lmer()` function for linear mixed-effects models. Since the normal distribution is the default assumption, you don't need to specify any family. Here's a basic example:"),
      tags$pre(tags$code("model <- lmer(reaction_time ~ condition + (1|participant), data = your_data)", class = "language-r")),
      p("This assumes your response variable (reaction_time) follows a normal distribution with random intercepts for participants."),
      h3("Bayesian (brms)"),
      p("To model data with a normal distribution in a Bayesian framework, you can use the `brm()` function from the `brms` package. Like lme4, the normal distribution is the default, so no family specification is needed:"),
      tags$pre(tags$code("model <- brm(reaction_time ~ condition + (1|participant), data = your_data)", class = "language-r"))
    )
  } else if (selected_dist == "Lognormal") {
    tagList(
      h3("Frequentist (lme4)"),
      p("The lme4 package does not directly support lognormal distributions. However, you can log-transform your data and use `lmer()` with the normal distribution:"),
      tags$pre(tags$code("model <- lmer(log(reaction_time) ~ condition + (1|participant), data = your_data)", class = "language-r")),
      p("Remember that your coefficients will be on the log scale and need back-transformation for interpretation."),
      h3("Bayesian (brms)"),
      p("brms supports lognormal distributions directly using the `lognormal()` family:"),
      tags$pre(tags$code("model <- brm(reaction_time ~ condition + (1|participant), family = lognormal(), data = your_data)", class = "language-r")),
      p("This is often preferable to log-transformation as it maintains the original scale for interpretation.")
    )
  } else if (selected_dist == "Student's t") {
    tagList(
      h3("Frequentist (lme4)"),
      p("The lme4 package does not support Student's t distributions for the response variable. lme4 assumes normally distributed residuals and uses t-distributions only for inference (confidence intervals and p-values)."),
      h3("Bayesian (brms)"),
      p("brms supports Student's t distributions using the `student()` family, which is useful for robust modeling when you expect outliers:"),
      tags$pre(tags$code("model <- brm(iq_score ~ group + (1|school), family = student(), data = your_data)", class = "language-r")),
      p("The t-distribution provides more robust estimates when your data contains extreme values that might unduly influence a normal model.")
    )
  } else if (selected_dist == "Beta") {
    tagList(
      h3("Frequentist (lme4)"),
      p("The lme4 package does not support beta distributions. For proportion data, you might consider using `glmer()` with a binomial family if you have count data, or transform your proportions using logit transformation."),
      h3("Bayesian (brms)"),
      p("brms supports beta distributions using the `Beta()` family, perfect for modeling proportions and percentages:"),
      tags$pre(tags$code("model <- brm(accuracy_rate ~ condition + (1|participant), family = Beta(), data = your_data)", class = "language-r")),
      p("Your response variable should be bounded between 0 and 1. If you have percentages (0-100), divide by 100 first.")
    )
  } else if (selected_dist == "Bernoulli") {
    tagList(
      h3("Frequentist (lme4)"),
      p("For Bernoulli (binary) data, use `glmer()` with the binomial family:"),
      tags$pre(tags$code("model <- glmer(correct ~ condition + (1|participant), family = binomial(), data = your_data)", class = "language-r")),
      p("Your response variable should be coded as 0/1 or FALSE/TRUE. The model will use logistic regression."),
      h3("Bayesian (brms)"),
      p("For Bernoulli data in brms, use the `bernoulli()` family:"),
      tags$pre(tags$code("model <- brm(correct ~ condition + (1|participant), family = bernoulli(), data = your_data)", class = "language-r")),
      p("Like with lme4, your response should be binary (0/1). The bernoulli() family is equivalent to binomial() for single trials.")
    )
  } else if (selected_dist == "Categorical") {
    tagList(
      h3("Frequentist (lme4)"),
      p("The lme4 package does not directly support categorical (multinomial) distributions for mixed-effects models. You would need to use packages like `MCMCglmm` or convert to binary comparisons."),
      h3("Bayesian (brms)"),
      p("brms supports categorical data using the `categorical()` family for multinomial responses:"),
      tags$pre(tags$code("model <- brm(choice ~ condition + (1|participant), family = categorical(), data = your_data)", class = "language-r")),
      p("Your response variable should be a factor with multiple levels (e.g., 'Option A', 'Option B', 'Option C'). brms will model the probability of each category.")
    )
  }
})



# Add these reactive UI elements to your server section:

# Calculate remaining probability
remaining_prob <- reactive({
  k <- input$cat_k
  if (is.null(k)) return(1)
  
  used_prob <- 0
  if (k >= 2 && !is.null(input$cat_p1)) used_prob <- used_prob + input$cat_p1
  if (k >= 3 && !is.null(input$cat_p2)) used_prob <- used_prob + input$cat_p2
  if (k >= 4 && !is.null(input$cat_p3)) used_prob <- used_prob + input$cat_p3
  if (k >= 5 && !is.null(input$cat_p4)) used_prob <- used_prob + input$cat_p4
  if (k >= 6 && !is.null(input$cat_p5)) used_prob <- used_prob + input$cat_p5
  if (k >= 7 && !is.null(input$cat_p6)) used_prob <- used_prob + input$cat_p6
  if (k >= 8 && !is.null(input$cat_p7)) used_prob <- used_prob + input$cat_p7
  if (k >= 9 && !is.null(input$cat_p8)) used_prob <- used_prob + input$cat_p8
  if (k >= 10 && !is.null(input$cat_p9)) used_prob <- used_prob + input$cat_p9
  
  max(0, 1 - used_prob)
})

# Display remaining probability
output$remaining_prob_display <- renderUI({
  remaining <- remaining_prob()
  color <- if (remaining < 0.01) "red" else "blue"
  tags$div(
    style = paste0("font-weight: bold; color: ", color, "; margin: 10px 0;"),
    sprintf("Remaining probability for last category: %.3f", remaining)
  )
})

# Dynamic sliders with constraints
output$cat_p1_slider <- renderUI({
  max_val <- min(0.98, remaining_prob() + (input$cat_p1 %||% 0.25))
  sliderInput("cat_p1", "P(Category 1)", 
              value = min(input$cat_p1 %||% 0.25, max_val), 
              min = 0.01, max = max_val, step = 0.01)
})

output$cat_p2_slider <- renderUI({
  if (input$cat_k < 3) return(NULL)
  max_val <- min(0.98, remaining_prob() + (input$cat_p2 %||% 0.25))
  sliderInput("cat_p2", "P(Category 2)", 
              value = min(input$cat_p2 %||% 0.25, max_val), 
              min = 0.01, max = max_val, step = 0.01)
})

output$cat_p3_slider <- renderUI({
  if (input$cat_k < 4) return(NULL)
  max_val <- min(0.98, remaining_prob() + (input$cat_p3 %||% 0.25))
  sliderInput("cat_p3", "P(Category 3)", 
              value = min(input$cat_p3 %||% 0.25, max_val), 
              min = 0.01, max = max_val, step = 0.01)
})

output$cat_p4_slider <- renderUI({
  if (input$cat_k < 5) return(NULL)
  max_val <- min(0.98, remaining_prob() + (input$cat_p4 %||% 0.1))
  sliderInput("cat_p4", "P(Category 4)", 
              value = min(input$cat_p4 %||% 0.1, max_val), 
              min = 0.01, max = max_val, step = 0.01)
})

output$cat_p5_slider <- renderUI({
  if (input$cat_k < 6) return(NULL)
  max_val <- min(0.98, remaining_prob() + (input$cat_p5 %||% 0.1))
  sliderInput("cat_p5", "P(Category 5)", 
              value = min(input$cat_p5 %||% 0.1, max_val), 
              min = 0.01, max = max_val, step = 0.01)
})

output$cat_p6_slider <- renderUI({
  if (input$cat_k < 7) return(NULL)
  max_val <- min(0.98, remaining_prob() + (input$cat_p6 %||% 0.05))
  sliderInput("cat_p6", "P(Category 6)", 
              value = min(input$cat_p6 %||% 0.05, max_val), 
              min = 0.01, max = max_val, step = 0.01)
})

output$cat_p7_slider <- renderUI({
  if (input$cat_k < 8) return(NULL)
  max_val <- min(0.98, remaining_prob() + (input$cat_p7 %||% 0.05))
  sliderInput("cat_p7", "P(Category 7)", 
              value = min(input$cat_p7 %||% 0.05, max_val), 
              min = 0.01, max = max_val, step = 0.01)
})

output$cat_p8_slider <- renderUI({
  if (input$cat_k < 9) return(NULL)
  max_val <- min(0.98, remaining_prob() + (input$cat_p8 %||% 0.05))
  sliderInput("cat_p8", "P(Category 8)", 
              value = min(input$cat_p8 %||% 0.05, max_val), 
              min = 0.01, max = max_val, step = 0.01)
})

output$cat_p9_slider <- renderUI({
  if (input$cat_k < 10) return(NULL)
  max_val <- min(0.98, remaining_prob() + (input$cat_p9 %||% 0.05))
  sliderInput("cat_p9", "P(Category 9)", 
              value = min(input$cat_p9 %||% 0.05, max_val), 
              min = 0.01, max = max_val, step = 0.01)
})
```
