---
title: "DevDist"
format:
   dashboard:
    theme:
    - sandstone
    - custom.scss
    fontsize: .9em   # works like CSS
server: shiny
---

```{r}
#| label: Libraries
#| context: setup
library(shiny)ster
library(bslib)
library(tinyplot)
```

```{=html}
<!-- Prism.js CSS (Dark theme similar to Zenburn) -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />

<!-- Prism.js Core -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>

<!-- R Language Support -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>

<!-- Auto-highlight new content -->
<script>
document.addEventListener('DOMContentLoaded', function() {
  // Re-highlight when Shiny updates content
  if (window.Shiny) {
    $(document).on('shiny:value shiny:outputinvalidated', function() {
      setTimeout(function() {
        Prism.highlightAll();
      }, 50);
    });
  }
  
  // Initial highlight
  Prism.highlightAll();
});
</script>


<script>
$(document).ready(function() {
  // Check URL on page load
  checkURLAndSetDist();
  
  // Check URL when tabs change
  $(document).on('shown.bs.tab', 'a[data-bs-toggle="tab"]', function (e) {
    checkURLAndSetDist();
  });
  
  function checkURLAndSetDist() {
    var hash = window.location.hash;
    if (hash.includes('?')) {
      var params = new URLSearchParams(hash.split('?')[1]);
      var dist = params.get('dist');
      if (dist && $('#dist_selection').length) {
        // For selectizeInput, use the selectize API
        var selectize = $('#dist_selection')[0].selectize;
        if (selectize) {
          selectize.setValue(dist);
        }
      }
    }
  }
});
</script>
```

# Welcome {orientation="columns"}

:::: card
<h1 style="color: #007e7e;">

Welcome to DevDist

</h1>

DevDist is an interactive **Distribution Explorer** tool designed to help you explore statistical distributions that may be useful for modeling your cognitive developmental data (and beyond).

This application highlights some of the most useful distributions commonly used in developmental research. Rather than serving as an exhaustive catalog or comprehensive statistical reference, DevDist aims to help you become familiar with key distributions, understand their parameters, and visualize how they behave under different conditions.

Consider this your starting point for exploring distributions and their characteristics. When you're ready to dive deeper, excellent resources are available online, including: [Distribution explorer](https://distribution-explorer.github.io/index.html) and [Probability Distributions Viewer](https://statdist.ksmzn.com)

<h3 style="color: #007e7e;">

What can you do here?

</h3>

This tool is divided into three main sections:

1.  **Welcome Page** You're currently on the landing page! While there isn't much interaction here, we'd like to draw your attention to the signal buttons in the bottom-left panel. These represent common physiological signals you might want to model. Simply click any button to jump directly to the Distribution Explorer with our recommended distribution for that signal type already selected.

2.  **Distribution Explorer** This is the heart of the application, where you can dive deep into statistical distributions:

    -   **Interactive Parameters**: Select any distribution from the dropdown menu and experiment with its parameters using intuitive sliders. Watch as the visualization updates in real-time to show how parameter changes affect the distribution's shape.
    -   **Educational Content**: Each distribution comes with a clear description explaining its characteristics, common applications, and the types of signals it's best suited to model.
    -   **Implementation Guide**: We provide examples using both **lme4** and **brms** frameworks. **lme4** offers excellent support for common distributions but has limitations - for less standard distributions, you'd typically need to rely on different specialized packages. In contrast, **brms** provides comprehensive support for a wide range of distributions within a single, consistent framework, making it our preferred choice for most distribution modeling tasks.

3.  **Check Your Data** Transform your own data into actionable insights by uploading a CSV file. This section helps you:

    -   **Visualize**: Generate clean, informative plots of your data distribution to understand its shape and characteristics.
    -   **Discover**: Use the powerful `fitdistrplus` package to create Cullen-Frey plots, which provide expert recommendations about which distributions might best approximate your data.
    -   **Compare**: Automatically fit multiple distributions to your data and compare their performance through visual diagnostics. The tool identifies the best-fitting distribution using AIC criteria, taking the guesswork out of model selection.

::: callout-warning
This is just my way to experiment with shiny and share some knowledghe in the process. In case you see something that can be improved or is not exact..just let me know!!
![](https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExcDZlcnV6ZHA4YXA3Zmo0NnA1MmxlYng4dmU4NzRlazQybXNxZGZsNSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/Oe7H865K0YPfY6ILXm/giphy.gif){width="55"}
:::
::::

## Column {width="30%"}

### Row {height="70%"}

```{r}
#| label: Cute plot of distributions - Responsive
plotOutput("welcome_distplot", 
           height = "100%", 
           width = "100%")
```

### Row {height="30%"}


```{r}
#| label: Signal badges
#| echo: false
HTML('<p>
    <span class="badge bg-primary me-2">IQ Scores</span>
    <span class="badge bg-primary me-2">Memory Span</span>
    <span class="badge bg-primary me-2">Standardized Test Scores</span>
    <span class="badge bg-primary me-2">Cognitive Ability Measures</span>
    <span class="badge bg-primary me-2">Personality Scale Scores</span>
    <span class="badge bg-primary me-2">Attitude Ratings (averaged)</span>
    <span class="badge bg-primary me-2">Measurement Error</span>
  </p>')
```

```{r}
HTML('<a href="#distributions?dist=Lognormal" style="text-decoration: none;">
  <span class="badge bg-primary me-2">Reaction Times</span>
</a>')
```

# Distributions

## Row

###  {.sidebar width="20%"}

```{r}
#| label: Distribution Selection
selectizeInput("dist_selection", "Select Distribution:",
              choices = list(
                "Continuous" = c("Normal", "Lognormal", "Student's t", "Beta"),
                "Categorical" = c("Bernoulli", "Categorical")
              ),
              selected = "Normal")
```

```{r}
#| label: Distributions Parameters
# Normal
conditionalPanel(
  condition = "input.dist_selection == 'Normal'",
  sliderInput("n_mu", "Mean (μ)", value = 0, min = -5, max = 5, step = 0.1),
  helpText(HTML("Moves the center left/right.<br>"),style = "font-size: 0.6rem;"),
  sliderInput("n_sigma", "SD (σ)", value = 1, min = 0.1, max = 3, step = 0.1),
  helpText(HTML("Controls width of the distribution.<br>"),style = "font-size: 0.6rem;")
)

# Lognormal
conditionalPanel(
  condition = "input.dist_selection == 'Lognormal'",
  sliderInput("ln_meanlog", "Log Mean (μ)", value = 0, min = -3, max = 3, step = 0.1),
  helpText(HTML("Mean of the underlying normal distribution.<br>"),style = "font-size: 0.6rem;"),
  sliderInput("ln_sdlog", "Log SD (σ)", value = 0.6, min = 0.1, max = 2, step = 0.1),
  helpText(HTML("SD of the underlying normal distribution.<br>"),style = "font-size: 0.6rem;")
)

# Student's t
conditionalPanel(
  condition = "input.dist_selection == 'Student\\'s t'",
  sliderInput("t_df", "Degrees of Freedom (ν)", value = 4, min = 1, max = 20, step = 1),
  helpText(HTML("Higher values approximate Normal (lighter tails).<br>"),style = "font-size: 0.6rem;"),
  sliderInput("t_mu", "Location (μ)", value = 0, min = -5, max = 5, step = 0.1),
  helpText(HTML("Shifts the distribution left/right.<br>"),style = "font-size: 0.6rem;"),
  sliderInput("t_sigma", "Scale (σ)", value = 1, min = 0.1, max = 3, step = 0.1),
  helpText(HTML("Controls spread (larger = wider).<br>"),style = "font-size: 0.6rem;")
)

# Beta
conditionalPanel(
  condition = "input.dist_selection == 'Beta'",
  radioButtons("beta_mode", "Parameterization:",
               c("Mean μ & Precision φ" = "muphi",
                 "Alpha & Beta" = "ab"),
               inline = TRUE),

  conditionalPanel(
    condition = "input.beta_mode == 'muphi'",
    sliderInput("b_mu", "Mean (μ in (0,1))", value = 0.3, min = 0.01, max = 0.99, step = 0.01),
    helpText(HTML("Shifts the peak between 0 and 1.<br>"),style = "font-size: 0.6rem;"),
    sliderInput("b_phi", "Precision (φ > 0)", value = 20, min = 1, max = 100, step = 1),
    helpText(HTML("Higher φ = more concentrated around μ.<br>"),style = "font-size: 0.6rem;")
  ),

  conditionalPanel(
    condition = "input.beta_mode == 'ab'",
    sliderInput("b_alpha", "Alpha (α > 0)", value = 3, min = 0.1, max = 20, step = 0.1),
    helpText(HTML("Higher α shifts toward 1.<br>"),style = "font-size: 0.6rem;"),
    sliderInput("b_beta", "Beta (β > 0)", value = 7, min = 0.1, max = 20, step = 0.1),
    helpText(HTML("Higher β shifts toward 0.<br>"),style = "font-size: 0.6rem;")
  )
)

# Bernoulli
conditionalPanel(
  condition = "input.dist_selection == 'Bernoulli'",
  sliderInput("bern_p", "Probability of Success (p)", value = 0.5, min = 0.01, max = 0.99, step = 0.01),
  helpText(HTML("Probability of getting 'Success' (or 'True').<br>"), style = "font-size: 0.6rem;"),
  radioButtons("bern_labels", "Outcome Labels:",
               c("Success/Failure" = "success",
                 "True/False" = "logical",
                 "Yes/No" = "yesno",
                 "1/0" = "binary"),
               selected = "success",
               inline = TRUE)
)

# Categorical with constrained probabilities
conditionalPanel(
  condition = "input.dist_selection == 'Categorical'",
  sliderInput("cat_k", "Number of categories (k)", value = 3, min = 2, max = 5, step = 1),
  helpText(HTML("Number of possible outcomes.<br>"), style = "font-size: 0.6rem;"),
  
  # Display remaining probability
  uiOutput("remaining_prob_display"),
  
  conditionalPanel(
    condition = "input.cat_k >= 2",
    uiOutput("cat_p1_slider")
  ),
  conditionalPanel(
    condition = "input.cat_k >= 3",
    uiOutput("cat_p2_slider")
  ),
  conditionalPanel(
    condition = "input.cat_k >= 4",
    uiOutput("cat_p3_slider")
  ),
  conditionalPanel(
    condition = "input.cat_k >= 5",
    uiOutput("cat_p4_slider")
  ),  
  helpText(HTML("Remaining probability is automatically assigned to the last category.<br>"), style = "font-size: 0.6rem;")
)
```

### Column {width="60%"}

####  {.tabset}

##### Plot

```{r}
#| label: Distribution Plot
plotOutput("dist_plot", height = 360)
```

##### Distribution Info

```{r}
#| label: Distribution Info
tagList(
  conditionalPanel(
    condition = "input.dist_selection == 'Normal'",
    HTML('<h2>Normal (Gaussian) Distribution</h2>'),
    HTML('<p>The normal distribution is the classic bell-shaped curve with perfect symmetry around its center. It has a single peak where most values cluster, with frequencies tapering off equally in both directions. The width of the curve reflects variability - wider curves indicate more spread in the data, while narrower curves show values tightly clustered around the mean.</p>'),
    HTML('<h3>What can it model?</h3>'),
    HTML('<p>This distribution models continuous data that clusters symmetrically around a central value, where extreme deviations in either direction are equally likely but become increasingly rare. It works best for measurements that result from multiple additive factors, aggregated scores, or standardized assessments where the underlying process produces balanced variation around a typical value.</p>')
  ),
  
  conditionalPanel(
    condition = "input.dist_selection == 'Lognormal'",
    HTML('<h2>Lognormal Distribution</h2>'),
    HTML('<p>The lognormal distribution is characterized by its distinctive right skew, creating a sharp rise followed by a long tail extending toward higher values. All values are strictly positive - the distribution never reaches zero. Most observations concentrate at the lower end, while occasional values stretch far into the upper range.</p>'),
    HTML('<h3>What can it model?</h3>'),
    HTML('<p>This distribution models positive-valued data with a natural lower bound but no upper limit, where fast or efficient responses are common but slower, more variable responses occasionally occur. It captures processes with inherent timing constraints where quick responses cluster together but processing difficulties, attention lapses, or individual differences can produce much longer latencies.</p>')
  ),
  
  conditionalPanel(
    condition = "input.dist_selection == 'Student\\'s t'",
    HTML('<h2>T-distribution</h2>'),
    HTML('<p>The t-distribution resembles the normal distribution but with notably heavier tails, making extreme values more probable than in a normal curve. As degrees of freedom increase, it approaches the normal distribution, but with fewer degrees of freedom, it becomes more accommodating of outlying observations.</p>'),
    HTML('<h3>What can it model?</h3>'),
    HTML('<p>This distribution models data that may contain legitimate extreme values, particularly when sample sizes are small or when individual differences are substantial. It provides robust modeling for situations where occasional extreme observations represent meaningful variation rather than measurement error, offering protection against the influence of valid but unusual data points.</p>')
  ),

  conditionalPanel(
    condition = "input.dist_selection == 'Beta'",
    HTML('<h2>Beta Distribution</h2>'),
    HTML('<p>The beta distribution is remarkably flexible in shape while being strictly bounded between 0 and 1. Depending on its parameters, it can appear uniform, U-shaped, bell-shaped, or heavily skewed toward either boundary. This bounded nature prevents impossible values while accommodating diverse patterns within the valid range.</p>'),
    HTML('<h3>What can it model?</h3>'),
    HTML('<p>This distribution models proportions, rates, and probabilities - any measurement that represents a fraction of a whole or success rate out of total attempts. It naturally handles data bounded between 0 and 1, making it ideal for performance measures, accuracy rates, or any variable expressing "how much out of the total possible."</p>')
  ),
  
  conditionalPanel(
    condition = "input.dist_selection == 'Bernoulli'",
    HTML('<h2>Bernoulli Distribution</h2>'),
    HTML('<p>The Bernoulli distribution is the simplest probability distribution, representing a single trial with exactly two possible outcomes. One outcome is designated as "success" (coded as 1) and the other as "failure" (coded as 0), with a fixed probability determining the likelihood of success.</p>'),
    HTML('<h3>What can it model?</h3>'),
    HTML('<p>This distribution models binary outcomes where each observation can only take one of two mutually exclusive states. It captures yes/no decisions, correct/incorrect responses, presence/absence judgments, or any situation where each trial results in exactly two possible categorical outcomes with no middle ground or partial responses.</p>')
  ),
    
  conditionalPanel(
    condition = "input.dist_selection == 'Categorical'",
    HTML('<h2>Categorical Distribution</h2>'),
    HTML('<p>The categorical distribution extends binary outcomes to multiple discrete categories. Each possible outcome has its own probability, and all probabilities sum to 1. Categories are mutually exclusive - each observation falls into exactly one category - and collectively exhaustive of all possibilities.</p>'),
    HTML('<h3>What can it model?</h3>'),
    HTML('<p>This distribution models discrete choice data where observations fall into one of several distinct, non-overlapping categories. It handles multinomial outcomes, classification data, or any measurement where participants or observations are assigned to one category from a finite set of mutually exclusive options.</p>')
  )
)
```

##### How to model

```{r}
#| label: How to model
tagList(
  conditionalPanel(
    condition = "input.dist_selection == 'Normal'",
    p("For normal distributions, both frequentist and Bayesian frameworks assume the same underlying model structure. The normal distribution is the default assumption in most linear models, so you typically don't need to specify a family parameter."),
    h3("Frequentist (lme4)"),
    p("Use ", code("lmer()"), " for linear mixed-effects models:"),
    pre(code("model <- lmer(outcome ~ fixed_effect + (1|random_effect), data = your_data)", class = "language-r")),
    p("Formula breakdown: ", code("outcome"), " is your dependent variable, ", code("fixed_effect"), " represents predictors with effects you want to estimate across the population, ", code("(1|random_effect)"), " adds random intercepts allowing baseline differences between groups (e.g., participants, schools)."),
    h3("Bayesian (brms)"),
    p("Use ", code("brm()"), " with the same formula syntax:"),
    pre(code("model <- brm(outcome ~ fixed_effect + (1|random_effect), data = your_data)", class = "language-r")),
    p("The formula structure is identical, but brms uses Bayesian estimation with prior distributions rather than maximum likelihood.")
  ),

  conditionalPanel(
    condition = "input.dist_selection == 'Lognormal'",
    p("Lognormal distributions are not supported in lme4. For right-skewed positive data, consider using brms for proper lognormal modeling."),
    h3("Frequentist (lme4)"),
    p("lme4 does not support lognormal distributions. You could use ", code("glmer()"), " with a Gamma family, though this is usually not ideal for truly lognormal data:"),
    pre(code("model <- glmer(outcome ~ fixed_effect + (1|random_effect), family = Gamma(link = 'log'), data = your_data)", class = "language-r")),
    h3("Bayesian (brms)"),
    p("brms supports lognormal distributions directly with the ", code("lognormal()"), " family:"),
    pre(code("model <- brm(outcome ~ fixed_effect + (1|random_effect), family = lognormal(), data = your_data)", class = "language-r")),
    p("This properly models the lognormal distribution and keeps coefficients interpretable on the original scale.")
  ),

  conditionalPanel(
    condition = "input.dist_selection == 'Student\\'s t'",
    p("Student's t distributions provide robust modeling for data with heavier tails than normal. Availability differs significantly between frameworks."),
    h3("Frequentist (lme4)"),
    p("lme4 does not support t-distributed response variables. It uses t-distributions only for inference (confidence intervals, p-values) assuming normally distributed residuals."),
    h3("Bayesian (brms)"),
    p("brms supports t-distributions using the ", code("student()"), " family:"),
    pre(code("model <- brm(outcome ~ fixed_effect + (1|random_effect), family = student(), data = your_data)", class = "language-r")),
    p("The model estimates degrees of freedom automatically, providing robust estimates when extreme values are present. Lower degrees of freedom indicate heavier tails.")
  ),

  conditionalPanel(
    condition = "input.dist_selection == 'Beta'",
    p("Beta distributions model bounded data between 0 and 1. Support differs between frameworks."),
    h3("Frequentist (lme4)"),
    p("lme4 does not support beta distributions. Use brms for proper beta modeling."),
    h3("Bayesian (brms)"),
    p("brms supports beta distributions:"),
    pre(code("model <- brm(proportion ~ fixed_effect + (1|random_effect), family = Beta(), data = your_data)", class = "language-r")),
    p("Your ", code("proportion"), " variable must be between 0 and 1 (exclusive). Convert percentages by dividing by 100.")
  ),

  conditionalPanel(
    condition = "input.dist_selection == 'Bernoulli'",
    p("Bernoulli distributions model binary outcomes. Both frameworks use similar approaches but with different family specifications."),
    h3("Frequentist (lme4)"),
    p("Use ", code("glmer()"), " with binomial family for binary data:"),
    pre(code("model <- glmer(binary_outcome ~ fixed_effect + (1|random_effect), family = binomial(), data = your_data)", class = "language-r")),
    p("The ", code("binary_outcome"), " should be coded as 0/1, TRUE/FALSE, or a factor. The model uses logistic regression with logit link function."),
    h3("Bayesian (brms)"),
    p("Use ", code("bernoulli()"), " family (equivalent to binomial for single trials):"),
    pre(code("model <- brm(binary_outcome ~ fixed_effect + (1|random_effect), family = bernoulli(), data = your_data)", class = "language-r")),
    p("The formula structure and data coding requirements are identical to the frequentist approach.")
  ),

  conditionalPanel(
    condition = "input.dist_selection == 'Categorical'",
    p("Categorical distributions model multinomial outcomes. Support varies dramatically between frameworks."),
    h3("Frequentist (lme4)"),
    p("lme4 cannot handle categorical responses with mixed effects. Consider alternative packages like ", code("MCMCglmm"), " or restructure as multiple binary comparisons using ", code("glmer()"), "."),
    h3("Bayesian (brms)"),
    p("brms supports categorical responses with the ", code("categorical()"), " family:"),
    pre(code("model <- brm(category ~ fixed_effect + (1|random_effect), family = categorical(), data = your_data)", class = "language-r")),
    p("The ", code("category"), " variable should be a factor (e.g., 'A', 'B', 'C'). brms estimates separate equations for each category relative to a reference level.")
  )
)
```

### Column {width="20%"}

```{r}
#| label: Summary Stats2
uiOutput("vb_moments")
```
























































```{r}
#| label: Server logic
#| context: server

# Custom function to replace brms::rstudent_t
rstudent_t_custom <- function(n, df, mu = 0, sigma = 1) {
  mu + sigma * rt(n, df)
}

############################# PAGE 1 #############################

# ---- Welcome page distributions plot ----
welcome_distributions_data <- reactive({
  set.seed(123)
  n_samples <- 100000  # keep smaller for speed with shiny
  
  df <- data.frame(
    Normal       = rnorm(n_samples, mean = 0, sd = 1),
    NormalLarge  = rnorm(n_samples, mean = 4, sd = 4),
    Binomial     = (rbinom(n_samples, size = 1, prob = .5) * 10) - 5,
    Lognormal    = rlnorm(n_samples, meanlog = 0.3, sdlog = 0.5),
    LognormalInv = rlnorm(n_samples, meanlog = 0.3, sdlog = 0.55) * -1 + -1,
    Student_t    = rstudent_t_custom(n_samples, df = 5, mu = .6, sigma = 1)
  )
  
  # Reshape to long format
  long_df <- stack(df)
  names(long_df) <- c("Value", "Distribution")
  
  long_df
})



output$welcome_distplot <- renderPlot({
  distributions_long <- welcome_distributions_data()
  distributions_long$Distribution <- factor(distributions_long$Distribution)
  
  
  tinytheme('void', mar = c(2, 2, 1, 1), oma = c(0, 0, 0, 0))
  tinyplot(
     ~ Value| Distribution, legend = FALSE,
    data = distributions_long,
    lwd = 4.5,
    type = "density",
    fill = 'by',
    alpha = 0.7,
    xlab = '',
    ylab = ''
  )
  tinytheme('default')

}, height = function() {
  session$clientData$output_welcome_distplot_height
}, width = function() {
  session$clientData$output_welcome_distplot_width
})



############################# PAGE 2 #############################

# Function to generate categorical samples
rcategorical <- function(n, probs) {
  sample(1:length(probs), n, replace = TRUE, prob = probs)
}

# ---- Reactive sampler ----
samples <- reactive({
  n_req <- 3000L
  selected_dist <- input$dist_selection
  continuous_dists <- c("Normal", "Lognormal", "Student's t", "Beta")
  
  if (selected_dist %in% continuous_dists) {
    if (selected_dist == "Normal") {
      rnorm(n_req, mean = input$n_mu, sd = input$n_sigma)
    } else if (selected_dist == "Lognormal") {
      rlnorm(n_req, meanlog = input$ln_meanlog, sdlog = input$ln_sdlog)
    } else if (selected_dist == "Student's t") {
      rstudent_t_custom(n_req, df = input$t_df, mu = input$t_mu, sigma = input$t_sigma)
    } else if (selected_dist == "Beta") {
      if (input$beta_mode == "ab") {
        alpha <- input$b_alpha
        beta  <- input$b_beta
      } else {
        mu  <- input$b_mu
        phi <- input$b_phi
        alpha <- mu * phi
        beta  <- (1 - mu) * phi
      }
      rbeta(n_req, shape1 = alpha, shape2 = beta)
    } else {
      validate(need(FALSE, "Unknown continuous distribution."))
    }
  } else {
    if (selected_dist == "Bernoulli") {
      rbinom(n_req, size = 1, prob = input$bern_p)
    } else if (selected_dist == "Categorical") {
      k <- input$cat_k
      probs <- numeric(k)
      
      probs[1] <- input$cat_p1 %||% 0.25
      if (k >= 3) probs[2] <- input$cat_p2 %||% 0.25
      if (k >= 4) probs[3] <- input$cat_p3 %||% 0.25
      if (k >= 5) probs[4] <- input$cat_p4 %||% 0.25
      
      # Assign remaining probability to last category
      probs[k] <- max(0.01, 1 - sum(probs[1:(k-1)]))
      
      rcategorical(n_req, probs)
    } else {
      validate(need(FALSE, "Unknown categorical distribution."))
    }
  }
})

output$dist_plot <- renderPlot({
  s <- samples()
  selected_dist <- input$dist_selection
  continuous_dists <- c("Normal", "Lognormal", "Student's t", "Beta")
 
  if (selected_dist %in% continuous_dists) {
    tinyplot(s, type = "density", lwd = 3,
            bw='SJ',
            adjust=.5,
            kernel = "gaussian",
            n = 512,
            main = paste("Sampled", selected_dist, "Distribution"),
            xlab = "",
            ylab = "",
            yaxt = "n",          # Remove y-axis ticks and labels
            col = "#007e7e",
            fill= "#007e7e",
            theme= "minimal")
   
    tinyplot_add(
      s,
      type = "hist",
      freq = FALSE,
      col = 'black',
      fill= 'transparent',
      lwd=1
    )
   
    abline(v = 0, col = "black", lty = 1, lwd = 4)
    abline(h = 0, col = "black", lty = 1, lwd = 4)
   
  } else {
    if (selected_dist == "Bernoulli") {
      counts <- table(s)
     
      if (input$bern_labels == "success") {
        labels <- c("Failure", "Success")
      } else if (input$bern_labels == "logical") {
        labels <- c("False", "True")
      } else if (input$bern_labels == "yesno") {
        labels <- c("No", "Yes")
      } else {
        labels <- c("0", "1")
      }
     
      y_vals <- as.numeric(counts) / length(s)
      x_pos <- 1:length(y_vals)
      plot_labels <- labels[as.numeric(names(counts)) + 1]
     
      plot(x_pos, y_vals,
           type = "n",
           main = paste("Bernoulli Distribution (p =", input$bern_p, ")"),
           xlab = "Outcome",
           ylab = "Probability",
           xaxt = "n",
           ylim = c(0, 1),
           xlim = c(0.5, length(y_vals) + 0.5))
     
      segments(x0 = x_pos, y0 = 0, x1 = x_pos, y1 = y_vals,
               col = "#007e7e", lwd = 4)
     
      points(x_pos, y_vals,
             pch = 19, cex = 2.5,
             col = "#007e7e")
      abline(h = 0, col = "black", lty = 1, lwd = 6 )

      axis(1, at = x_pos, labels = plot_labels)
     
      text(x_pos, y_vals + 0.05,
           labels = sprintf("%.3f", y_vals),
           cex = 0.9, pos = 3)
             
    } else if (selected_dist == "Categorical") {
      counts <- table(s)
      x_vals <- paste("Cat", names(counts))
      y_vals <- as.numeric(counts) / length(s)
     
      x_pos <- 1:length(y_vals)
     
      plot(x_pos, y_vals,
           type = "n",
           main = paste("Sampled Categorical Distribution (k=", input$cat_k, ")"),
           xlab = "Category",
           ylab = "Probability",
           xaxt = "n",
           ylim = c(0, max(y_vals) * 1.15),
           xlim = c(0.5, length(y_vals) + 0.5))
     
      segments(x0 = x_pos, y0 = 0, x1 = x_pos, y1 = y_vals,
               col = "#007e7e", lwd = 4)
     
      points(x_pos, y_vals,
             pch = 19, cex = 2.5,
             col = "#007e7e")
      abline(h = 0, col = "black", lty = 1, lwd = 6)

      axis(1, at = x_pos, labels = x_vals)
     
      text(x_pos, y_vals + max(y_vals) * 0.05,
           labels = sprintf("%.3f", y_vals),
           cex = 0.8, pos = 3)
    }
  }
}, height = function() {
  session$clientData$output_dist_plot_height
}, width = function() {
  session$clientData$output_dist_plot_width
}, res = 96)

# ---- Summary stats ----
stats <- reactive({
  s <- samples()
  selected_dist <- input$dist_selection
  n <- length(s)
  continuous_dists <- c("Normal", "Lognormal", "Student's t", "Beta")
  
  if (selected_dist %in% continuous_dists) {
    q <- quantile(s, c(0.25, 0.75), names = FALSE)
    list(
      mean   = mean(s),
      median = median(s),
      sd     = sd(s),
      se     = sd(s) / sqrt(n),
      min    = min(s),
      q1     = q[1],
      q3     = q[2],
      max    = max(s),
      type   = "continuous"
    )
  } else {
    list(
      mean   = mean(s),
      median = median(s),
      mode   = as.numeric(names(sort(table(s), decreasing = TRUE))[1]),
      var    = var(s),
      min    = min(s),
      max    = max(s),
      type   = "categorical"
    )
  }
})

output$vb_moments <- renderUI({
  st <- stats()
  selected_dist <- input$dist_selection
  
  get_distribution_badges <- function(dist_name) {
    switch(dist_name,
      "Normal" = list(
        "Looking time", "IQ Scores", "Memory Span", "Standardized Test Scores"
      ),
      "Lognormal" = list(
        "Reaction Times", "Saccadic Latencies", "Decision Times", "Time-to-Complete Tasks"
      ),
      "Student's t" = list(
        "Small Sample Studies", "Individual Differences", "Clinical Assessments", "Personality Scores"
      ),
      "Beta" = list(
        "Accuracy Rates", "Proportion Correct", "Confidence Ratings (0-1)", "Probability Judgments", "Response Proportions"
      ),
      "Bernoulli" = list(
        "Correct/Incorrect Response", "Detect/Miss (Signal Detection)", "Recall/Forget", "Choose Option A/B", "Attend/Ignore", "Present/Absent Judgment"
      ),
      "Categorical" = list(
        "Likert Scale Responses", "Multiple Choice Answers", "Emotional State Categories", "Diagnostic Categories", "Personality Types"
      ),
      list()
    )
  }
  
  create_badges <- function(badge_list) {
    if (length(badge_list) == 0) return("")
    
    badges_html <- paste(
      sapply(badge_list, function(badge) {
        paste0('<span class="badge bg-primary me-2 mb-1">', badge, '</span>')
      }), 
      collapse = '<br>'
    )
    return(badges_html)
  }
  
  badges <- get_distribution_badges(selected_dist)
  badges_html <- create_badges(badges)
 
  if (st$type == "continuous") {
    tagList(
      tags$div(style = "background-color: #f8f9fa; border-radius: 8px; padding: 15px; margin-bottom: 20px;",
        tags$h4("Center & Spread", style = "margin-bottom: 12px; color: #495057; font-weight: 600;"),
        tags$div(style = "font-size: 0.9rem; line-height: 1.4; margin-bottom: 8px; color: #6c757d;",
                 sprintf("Mean: %.3f | Median: %.3f", st$mean, st$median)),
        tags$div(style = "font-size: 0.9rem; line-height: 1.4; color: #6c757d;",
                 sprintf("SD: %.3f | SE: %.3f", st$sd, st$se))
      ),
      tags$div(style = "background-color: #f8f9fa; border-radius: 8px; padding: 15px; margin-bottom: 20px;",
        tags$h4("Range & Quartiles", style = "margin-bottom: 12px; color: #495057; font-weight: 600;"),
        tags$div(style = "font-size: 0.9rem; line-height: 1.4; margin-bottom: 8px; color: #6c757d;",
                 sprintf("Min: %.3f | Max: %.3f", st$min, st$max)),
        tags$div(style = "font-size: 0.9rem; line-height: 1.4; color: #6c757d;",
                 sprintf("Q1: %.3f | Q3: %.3f", st$q1, st$q3))
      ),
      tags$div(style = "background-color: #f8f9fa; border-radius: 8px; padding: 15px; margin-bottom: 20px;",
        tags$h4("Example Data Types", style = "margin-bottom: 12px; color: #495057; font-weight: 600;"),
        HTML(badges_html)
      )
    )
  } else {
    tagList(
      tags$div(style = "background-color: #f8f9fa; border-radius: 8px; padding: 15px; margin-bottom: 20px;",
        tags$h4("Center & Spread", style = "margin-bottom: 12px; color: #495057; font-weight: 600;"),
        tags$div(style = "font-size: 0.9rem; line-height: 1.4; margin-bottom: 8px; color: #6c757d;",
                 sprintf("Mean: %.3f | Mode: %.0f", st$mean, st$mode)),
        tags$div(style = "font-size: 0.9rem; line-height: 1.4; color: #6c757d;",
                 sprintf("Variance: %.3f", st$var))
      ),
      tags$div(style = "background-color: #f8f9fa; border-radius: 8px; padding: 15px; margin-bottom: 20px;",
        tags$h4("Range", style = "margin-bottom: 12px; color: #495057; font-weight: 600;"),
        tags$div(style = "font-size: 0.9rem; line-height: 1.4; color: #6c757d;",
                 sprintf("Min: %.0f | Max: %.0f", st$min, st$max))
      ),
      tags$div(style = "background-color: #f8f9fa; border-radius: 8px; padding: 15px; margin-bottom: 20px;",
        tags$h4("Example Data Types", style = "margin-bottom: 12px; color: #495057; font-weight: 600;"),
        HTML(badges_html)
      )
    )
  }
})

# Simplified remaining probability calculation
remaining_prob <- reactive({
  k <- input$cat_k
  if (is.null(k) || k < 2) return(1)
  
  used_prob <- (input$cat_p1 %||% 0) + 
               (if(k >= 3) input$cat_p2 %||% 0 else 0) + 
               (if(k >= 4) input$cat_p3 %||% 0 else 0) + 
               (if(k >= 5) input$cat_p4 %||% 0 else 0)
  
  max(0, 1 - used_prob)
})

output$remaining_prob_display <- renderUI({
  remaining <- remaining_prob()
  color <- if (remaining < 0.01) "red" else "blue"
  tags$div(
    style = paste0("font-weight: bold; color: ", color, "; margin: 10px 0;"),
    sprintf("Remaining probability for last category: %.3f", remaining)
  )
})

output$cat_p1_slider <- renderUI({
  max_val <- min(0.98, remaining_prob() + (input$cat_p1 %||% 0.25))
  sliderInput("cat_p1", "P(Category 1)", 
              value = min(input$cat_p1 %||% 0.25, max_val), 
              min = 0.01, max = max_val, step = 0.01)
})

output$cat_p2_slider <- renderUI({
  if (input$cat_k < 3) return(NULL)
  max_val <- min(0.98, remaining_prob() + (input$cat_p2 %||% 0.25))
  sliderInput("cat_p2", "P(Category 2)", 
              value = min(input$cat_p2 %||% 0.25, max_val), 
              min = 0.01, max = max_val, step = 0.01)
})

output$cat_p3_slider <- renderUI({
  if (input$cat_k < 4) return(NULL)
  max_val <- min(0.98, remaining_prob() + (input$cat_p3 %||% 0.25))
  sliderInput("cat_p3", "P(Category 3)", 
              value = min(input$cat_p3 %||% 0.25, max_val), 
              min = 0.01, max = max_val, step = 0.01)
})

output$cat_p4_slider <- renderUI({
  if (input$cat_k < 5) return(NULL)
  max_val <- min(0.98, remaining_prob() + (input$cat_p4 %||% 0.1))
  sliderInput("cat_p4", "P(Category 4)", 
              value = min(input$cat_p4 %||% 0.1, max_val), 
              min = 0.01, max = max_val, step = 0.01)
})


observeEvent(input$lognormal_badge, {
  # Navigate to distributions tab (if using tabsetPanel)
  # updateTabsetPanel(session, "main_tabs", selected = "Distributions")
  
  # Set the distribution
  updateSelectizeInput(session, "dist_selection", selected = "Lognormal")
})

```